"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[1894],{3905:(e,n,a)=>{a.d(n,{Zo:()=>d,kt:()=>h});var t=a(7294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function p(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=t.createContext({}),l=function(e){var n=t.useContext(o),a=n;return e&&(a="function"==typeof e?e(n):p(p({},n),e)),a},d=function(e){var n=l(e.components);return t.createElement(o.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=l(a),u=r,h=c["".concat(o,".").concat(u)]||c[u]||m[u]||i;return a?t.createElement(h,p(p({ref:n},d),{},{components:a})):t.createElement(h,p({ref:n},d))}));function h(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,p=new Array(i);p[0]=u;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[c]="string"==typeof e?e:r,p[1]=s;for(var l=2;l<i;l++)p[l]=a[l];return t.createElement.apply(null,p)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8860:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>p,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var t=a(7462),r=(a(7294),a(3905));const i={sidebar_position:9,description:"Marco extensions"},p="Macros",s={unversionedId:"developers/macros",id:"developers/macros",title:"Macros",description:"Marco extensions",source:"@site/docs/developers/macros.md",sourceDirName:"developers",slug:"/developers/macros",permalink:"/docs/developers/macros",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/developers/macros.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,description:"Marco extensions"},sidebar:"devSidebar",previous:{title:"Lurk",permalink:"/docs/developers/lurk"},next:{title:"Deployment",permalink:"/docs/developers/deployment"}},o={},l=[{value:"Nesting",id:"nesting",level:2},{value:"Macro Definitions",id:"macro-definitions",level:2},{value:"Def",id:"def",level:3},{value:"Defrec",id:"defrec",level:3},{value:"Defun",id:"defun",level:3},{value:"Assert",id:"assert",level:3},{value:"Assert-eq",id:"assert-eq",level:3},{value:"List",id:"list",level:3},{value:"Param",id:"param",level:3},{value:"Import",id:"import",level:2}],d={toc:l},c="wrapper";function m(e){let{components:n,...a}=e;return(0,r.kt)(c,(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"macros"},"Macros"),(0,r.kt)("p",null,"Lurk syntax can be difficult for read and write at times. Especially inside a lambda function where complex code often\nrequires many levels of nested expression. "),(0,r.kt)("p",null,"For this reason it's common for Lisp dialects to define a number of ",(0,r.kt)("inlineCode",{parentName:"p"},"macros")," that simplify the syntax and improve readability."),(0,r.kt)("p",null,"Ilxd offers a list of macros for this purpose. It should be noted that the following macros are ",(0,r.kt)("strong",{parentName:"p"},"NOT")," part of the\nLurk language. Rather ilxd has a ",(0,r.kt)("inlineCode",{parentName:"p"},"PreProcessor")," class that parses lurk code and expands the macros into pure lurk code."),(0,r.kt)("p",null,"When you commit to an unlocking function in illium, that function will always be pure lurk. If your code contains macros\nit will essentially be compiled into pure lurk before the commitment is made."),(0,r.kt)("h2",{id:"nesting"},"Nesting"),(0,r.kt)("p",null,"The macros defined here make it so that you can avoid the pattern of using many levels of nested expressions. Instead, the\nmacro preprocessor will handle the nesting when the macros are expanded into pure lurk. This is true even when multiple\nmacros are used  in succession and there are a number of levels of nesting."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(def x 3)\n!(def y 4)\n\n(+ x y)\n")),(0,r.kt)("p",null,"Macro expands into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3))\n     (let ((y 4))\n          (+ x y)\n     )\n)\n")),(0,r.kt)("p",null,"Evaluates to: ",(0,r.kt)("inlineCode",{parentName:"p"},"7")),(0,r.kt)("p",null,"You just need to make sure your unlocking function still returns ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"nil")," as the last expression. "),(0,r.kt)("h2",{id:"macro-definitions"},"Macro Definitions"),(0,r.kt)("h3",{id:"def"},"Def"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(def x 3)\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x 3))\n    <expression>\n)\n")),(0,r.kt)("h3",{id:"defrec"},"Defrec"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(defrec x 3)\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((x 3))\n    <expression>\n)\n")),(0,r.kt)("h3",{id:"defun"},"Defun"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(defun foo (x) (+ x 3))\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((foo (lambda (x) (+ x 3))))\n        <expression>\n)\n")),(0,r.kt)("h3",{id:"assert"},"Assert"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(assert (= 5 5))\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (eq (= 5 5) nil)\n     nil\n     <expression>\n)\n")),(0,r.kt)("h3",{id:"assert-eq"},"Assert-eq"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(assert-eq (cons 1 2) (cons 1 2))\n<expression>\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (eq (eq (cons 1 2) (cons 1 2)) nil)\n     nil\n     <expression>\n)\n")),(0,r.kt)("h3",{id:"list"},"List"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(list 1 2 3 4)\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(cons 1 (cons 2 (cons 3 (cons 4 nil))))\n")),(0,r.kt)("h3",{id:"param"},"Param"),(0,r.kt)("p",null,"The param macro serves as a helpful shortcut for accessing the parameters of the unlocking function. It has multiple\nforms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(param txo-root)                                     ;; expands to: (nth 1 public-params)\n!(param fee)                                          ;; expands to: (nth 2 public-params)\n!(param coinbase)                                     ;; expands to: (nth 3 public-params)\n!(param mint-id)                                      ;; expands to: (nth 4 public-params)\n!(param mint-amount)                                  ;; expands to: (nth 5 public-params)\n!(param sighash)                                      ;; expands to: (nth 7 public-params)\n!(param locktime)                                     ;; expands to: (nth 8 public-params)\n!(param locktime-precision)                           ;; expands to: (nth 9 public-params)\n\n!(param nullifiers <index>)                           ;; expands to: (nth <index> (nth 0 public-params))\n!(param pub-out <index>)                              ;; expands to: (nth <index> (nth 6 public-params))\n!(param pub-out <index> commitment)                   ;; expands to: (nth 0 (nth <index> (nth 6 public-params)))\n!(param pub-out <index> ciphertext)                   ;; expands to: (nth 1 (nth <index> (nth 6 public-params)))\n\n!(param priv-in <index>)                              ;; expands to: (nth <index> (car private-params))\n!(param priv-in <index> scirpt-commitment)            ;; expands to: (nth 0 (nth <index> (car private-params)))\n!(param priv-in <index> amount)                       ;; expands to: (nth 1 (nth <index> (car private-params)))\n!(param priv-in <index> asset-id)                     ;; expands to: (nth 2 (nth <index> (car private-params)))\n!(param priv-in <index> script-params)                ;; expands to: (nth 3 (nth <index> (car private-params)))\n!(param priv-in <index> commitment-index              ;; expands to: (nth 4 (nth <index> (car private-params)))\n!(param priv-in <index> state)                        ;; expands to: (nth 5 (nth <index> (car private-params)))\n!(param priv-in <index> salt)                         ;; expands to: (nth 6 (nth <index> (car private-params)))\n!(param priv-in <index> unlocking-params)             ;; expands to: (nth 7 (nth <index> (car private-params)))\n!(param priv-in <index> inclusion-proof-hashes)       ;; expands to: (nth 8 (nth <index> (car private-params)))\n!(param priv-in <index> inclusion-proof-accumulator)  ;; expands to: (nth 9 (nth <index> (car private-params)))\n!(param priv-in <index> script-hash)                  ;; expands to: (hash (cons ((car (nth <index> (car private-params))) (cons (nth 3 (nth <index> (car private-params))) nil)))\n\n!(param priv-out <index>)                             ;; expands to: (nth <index> (car (cdr private-params)))\n!(param priv-out <index> script-hash)                 ;; expands to: (nth 0 (nth <index> (car (cdr private-params))))\n!(param priv-out <index> amount)                      ;; expands to: (nth 1 (nth <index> (car (cdr private-params))))\n!(param priv-out <index> asset-id)                    ;; expands to: (nth 2 (nth <index> (car (cdr private-params))))\n!(param priv-out <index> state)                       ;; expands to: (nth 3 (nth <index> (car (cdr private-params))))\n!(param priv-out <index> salt)                        ;; expands to: (nth 4 (nth <index> (car (cdr private-params))))\n")),(0,r.kt)("h2",{id:"import"},"Import"),(0,r.kt)("p",null,"The preprocessor offers some limited package management facilities. Library files can be created with the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(module math (\n        !(defun plus-two (x) (+ x 2))\n        !(defun plus-three (x) (+ x 3))\n))\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Library files must use the ",(0,r.kt)("inlineCode",{parentName:"li"},".lurk")," file extension."),(0,r.kt)("li",{parentName:"ul"},"Library files may contain more than one module."),(0,r.kt)("li",{parentName:"ul"},"Modules must only make use of macros."),(0,r.kt)("li",{parentName:"ul"},"Modules may import other modules, but cannot do circular imports."),(0,r.kt)("li",{parentName:"ul"},"All top level functions and variables defined in the module are exported.")),(0,r.kt)("p",null,"The preprocessor takes in a dependency directory as an argument. The dependency directory may have sub-directories."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"/deps\n  |-- /std\n  |   |-- mod.lurk\n  |-- /utils\n  |   |-- mod.lurk\n")),(0,r.kt)("p",null,"Assume the ",(0,r.kt)("inlineCode",{parentName:"p"},"math")," module defined above was inside ",(0,r.kt)("inlineCode",{parentName:"p"},"/deps/std/mod.lurk"),", you would import it as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"!(import std/math)\n\n(plus-two (plus-three 5))\n")),(0,r.kt)("p",null,"Macro expands to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(letrec ((plus-two (lambda (x) (+ x 2))))\n        (letrec ((plus-three (lambda (x) (+ x 3))))\n                (plus-two (plus-three 5)) \n        )\n)\n")),(0,r.kt)("p",null,"Evaluates to: ",(0,r.kt)("inlineCode",{parentName:"p"},"10")))}m.isMDXComponent=!0}}]);