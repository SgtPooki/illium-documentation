"use strict";(self.webpackChunkillium_documentation=self.webpackChunkillium_documentation||[]).push([[926],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(n),m=i,d=h["".concat(c,".").concat(m)]||h[m]||p[m]||o;return n?a.createElement(d,r(r({ref:t},u),{},{components:n})):a.createElement(d,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1331:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:6},r="Data Messages",s={unversionedId:"api/data_messages",id:"api/data_messages",title:"Data Messages",description:"",source:"@site/docs/api/data_messages.md",sourceDirName:"api",slug:"/api/data_messages",permalink:"/docs/api/data_messages",draft:!1,editUrl:"https://github.com/project-illium/illium-documentation/docs/api/data_messages.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"apiSidebar",previous:{title:"Wallet Server Service",permalink:"/docs/api/wallet_server"},next:{title:"Notifications",permalink:"/docs/api/notifications"}},c={},l=[],u={toc:l},h="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-messages"},"Data Messages"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"message TransactionData {\n    oneof txids_or_txs {\n        // Just the transaction ID\n        bytes transaction_ID    = 1;\n        // A marshaled transaction.\n        Transaction transaction = 2;\n    }\n}\n\nmessage BlockInfo {\n    // The hash of the block header.\n    bytes  block_ID   = 1;\n    // A version number to track software/protocol upgrades.\n    uint32 version    = 2;\n    // The height of the block in the chain.\n    uint32 height     = 3;\n    // The block in the chain right before this one.\n    bytes parent      = 4;\n    // The next block in the chain (or nil if this block is the tip).\n    bytes child       = 5;\n    // The timestamp of the block. Expressed in seconds since 1970-01-01.\n    int64 timestamp   = 6;\n    // The root of the Merkle Tree built from all transactions in the block.\n    bytes tx_root     = 7;\n    // The peerID of the validator that created the block.\n    bytes producer_ID = 8;\n    // The size of the block in bytes.\n    uint32 size       = 9;\n    // The number of transactions in the block.\n    uint32 num_txs    = 10;\n}\n\nmessage Validator {\n    // The validator ID encoded in bytes.\n    bytes validator_ID        = 1;\n    // The number of coins staked by this validator.\n    uint64 total_stake        = 2;\n    // The total stake weighted by time lock.\n    uint64 stake_weight       = 3;\n    // The nullifiers for the utxos the validator has staked.\n    repeated Stake stake      = 4;\n    // The total of any unclaimed validator rewards.\n    uint64 unclaimed_coins    = 5;\n    // The number of blocks this validator has created this epoch.\n    uint32 epoch_blocks       = 6;\n    \n    message Stake {\n        // The nullifier that is staked\n        bytes nullifier           = 1;\n        // The amount staked\n        uint64 amount             = 2;\n        // The timestamp that this utxo is timelocked until\n        int64 timelocked_until    = 3;\n        // When this nullifier will expire and be removed from\n        // the validator set.\n        int64 expiration          = 4;\n        // The earliest date at which this nullifier can be restaked.\n        // One week before expiration.\n        int64 restake_eligibility = 5;\n    }\n}\n\n\nmessage Utxo {\n    // The commitment associated with the output\n    bytes commitment    = 1;\n    // The amount of coins\n    uint64 amount       = 2;\n    // The address that the utxo is associated with\n    string address      = 3;\n    // Whether or not this is a watch only utxo.\n    // We canot spend watch only utxos without the\n    // private key.\n    bool watchOnly      = 4;\n    // Is this utxo staked by the wallet.\n    bool staked         = 5;\n    // The timestamp this utxo is timelocked until (if applicable)\n    int64 locked_untill = 6;\n}\n\nmessage RawTransaction {\n    // The transaction as it appears on the network\n    Transaction tx                 = 1;\n    // The private (hidden) data for each input\n    repeated PrivateInput inputs   = 2;\n    // The private (hidden) data for each output\n    repeated PrivateOutput outputs = 3;\n}\n\nmessage PrivateInput {\n    // The amount of the input\n    uint64 amount                   = 1;\n    // Input salt\n    bytes salt                      = 2;\n    // Input asset ID\n    bytes asset_ID                  = 3;\n    // Input state\n    bytes state                     = 4;\n    // The unlocking function commitment\n    bytes script_commitment         = 5;\n    // The unlocking function parameters\n    repeated bytes script_params    = 6;\n    // The txo proof linking the input\n    // commitment to the accumulator\n    TxoProof txo_proof              = 7;\n}\n\nmessage PrivateOutput {\n    // Output amount\n    uint64 amount     = 1;\n    // Output salt\n    bytes salt        = 2;\n    // Output asset ID\n    bytes asset_ID    = 3;\n    // Output state\n    bytes state       = 4;\n    // Output scriptHash\n    bytes script_hash = 5;\n}\n\nmessage TxoProof {\n    // The commitment this inclusion proof is for\n    bytes commitment           = 1;\n    // The hashes that form the root preimage\n    repeated bytes accumulator = 2;\n    // The merkle hashes linking the commitment to the accumulator\n    repeated bytes hashes      = 3;\n    // Flags indicate whether a hash in the hash list is left or right.\n    // 0 == left, 1 == right.\n    uint64 flags               = 4;\n    // The index of this commitment in the tree\n    uint64 index               = 5;\n    // The txoRoot this proof links to. This is found in the block header.\n    bytes txoRoot              = 6;\n}\n\nmessage Peer {\n    // Peer ID\n    string id             = 1;\n    // The peer's user agent string\n    string user_agent     = 2;\n    // Multiaddrs\n    repeated string addrs = 3;\n    }\n    \n    message WalletTransaction {\n        // Transaction ID\n        bytes transaction_ID = 1;\n        // The net number of coins coming into the wallet\n        // Positive = receive\n        // Negative = send\n        int64 netCoins      = 2;\n    }\n")))}p.isMDXComponent=!0}}]);